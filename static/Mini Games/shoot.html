<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/png" href="/static/logo/favicon2.png">

    <title>Shooter Mini</title>
    <style>
        body {
            margin: 0;
            padding: 20px 0;
            overflow-x: hidden;
            overflow-y: auto;
            background-color: #111;
            font-family: 'Helvetica', 'Arial', sans-serif;
            color: #fff;
        }
        .game-wrapper {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            width: 100%;
            min-height: 100vh;
            box-sizing: border-box;
        }
        #game-heading {
            max-width: 90%;
            width: 300px;
            height: auto;
            margin-bottom: 15px;
        }
        canvas {
            background-color: #000;
            border: 1px solid #444;
            flex-shrink: 0;
        }
        #game-instructions {
            margin-top: 15px;
            text-align: center;
            color: #ccc;
            font-size: 14px;
            max-width: 90%;
        }
        #game-instructions p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <!-- IMPORTANT: Create a file named 'sahasam.png' and place it here -->
        <img src="shooting/sahasam.png" alt="Game Title" id="game-heading">
        <canvas id="gameCanvas"></canvas>
        <div id="game-instructions">
            <p><strong>Controls:</strong></p>
            <p><strong>Desktop:</strong> Move mouse to aim, Click to shoot.</p>
            <p><strong>Mobile:</strong> Drag finger to aim, Tap to shoot.</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');

            let width, height;

            function resizeCanvas() {
                const isMobile = window.matchMedia("(max-width: 768px)").matches;

                if (isMobile) {
                    width = canvas.width = Math.min(window.innerWidth - 20, 300);
                    height = canvas.height = Math.min(window.innerHeight - 200, 300); // adjust for vertical space
                } else {
                    width = canvas.width = Math.min(window.innerWidth - 20, 800);
                    height = canvas.height = Math.min(window.innerHeight - 200, 500); // adjust for vertical space
                }
            }

            // --- UTILITY FUNCTIONS ---
            function getAngle(x1, y1, x2, y2) {
                return Math.atan2(y2 - y1, x2 - x1);
            }

            function getDistance(x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                return Math.sqrt(dx * dx + dy * dy);
            }

            function isPointInRect(px, py, rect) {
                if (!rect) return false;
                return px > rect.x && px < rect.x + rect.width && py > rect.y && py < rect.y + rect.height;
            }

            // --- INPUT HANDLER ---
            class InputHandler {
                constructor(game) {
                    this.game = game;
                    this.mouseX = 0;
                    this.mouseY = 0;

                    const handleMove = (e) => {
                        const rect = canvas.getBoundingClientRect();
                        this.mouseX = (e.clientX || e.touches[0].clientX) - rect.left;
                        this.mouseY = (e.clientY || e.touches[0].clientY) - rect.top;
                    };

                    const handleClick = (e) => {
                        e.preventDefault();
                        const rect = canvas.getBoundingClientRect();
                        const clickX = (e.clientX || e.touches[0].clientX) - rect.left;
                        const clickY = (e.clientY || e.touches[0].clientY) - rect.top;

                        switch (this.game.state) {
                            case 'HOME':
                                if (isPointInRect(clickX, clickY, this.game.startButton)) {
                                    this.game.startNewGame();
                                }
                                break;
                            case 'PLAYING':
                                this.game.player.shoot(this.mouseX, this.mouseY);
                                break;
                            case 'WIN':
                                if (isPointInRect(clickX, clickY, this.game.homeButton)) {
                                    this.game.goToHome();
                                }
                                break;
                            case 'LOSE':
                                if (isPointInRect(clickX, clickY, this.game.tryAgainButton)) {
                                    this.game.startNewGame();
                                } else if (isPointInRect(clickX, clickY, this.game.homeButton)) {
                                    this.game.goToHome();
                                }
                                break;
                        }
                    };

                    canvas.addEventListener('mousemove', handleMove);
                    canvas.addEventListener('touchmove', handleMove, { passive: false });
                    canvas.addEventListener('mousedown', handleClick);
                    canvas.addEventListener('touchstart', handleClick, { passive: false });
                }
            }

            // --- PARTICLE EFFECT ---
            class Particle {
                constructor(x, y, color) {
                    this.x = x;
                    this.y = y;
                    this.color = color;
                    this.size = Math.random() * 5 + 2;
                    this.speedX = Math.random() * 6 - 3;
                    this.speedY = Math.random() * 6 - 3;
                    this.life = 1;
                    this.decay = 0.02;
                }

                update() {
                    this.x += this.speedX;
                    this.y += this.speedY;
                    this.life -= this.decay;
                    if (this.size > 0.2) this.size -= 0.1;
                }

                draw(ctx) {
                    ctx.fillStyle = this.color;
                    ctx.globalAlpha = this.life;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.globalAlpha = 1;
                }
            }

            // --- PROJECTILE ---
            class Projectile {
                constructor(x, y, angle, game) {
                    this.x = x;
                    this.y = y;
                    this.radius = game.isMobile ? 3 : 5;
                    this.speed = 8;
                    this.velocityX = Math.cos(angle) * this.speed;
                    this.velocityY = Math.sin(angle) * this.speed;
                    this.color = `hsl(${Math.random() * 360}, 100%, 70%)`;
                }

                update() {
                    this.x += this.velocityX;
                    this.y += this.velocityY;
                }

                draw(ctx) {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // --- TARGET ---
            class Target {
                constructor(game) {
                    if (game.isMobile) {
                        this.radius = Math.random() * 10 + 8;
                    } else {
                        this.radius = Math.random() * 20 + 15;
                    }
                    this.x = Math.random() * (width - this.radius * 2) + this.radius;
                    this.y = Math.random() * (height * 0.6) + this.radius;
                    this.speedX = (Math.random() * 4 - 2) || 1;
                    this.color = `hsl(${Math.random() * 360}, 70%, 60%)`;
                }

                update() {
                    this.x += this.speedX;
                    if (this.x - this.radius < 0 || this.x + this.radius > width) {
                        this.speedX *= -1;
                    }
                }

                draw(ctx) {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // --- PLAYER ---
            class Player {
                constructor(game) {
                    this.game = game;
                    this.color = '#eee';
                    this.turretAngle = -Math.PI / 2;
                    this.resize();
                }
                
                update(aimX, aimY) {
                    this.turretAngle = getAngle(this.x, this.y, aimX, aimY);
                }

                draw(ctx) {
                    ctx.fillStyle = this.color;
                    ctx.beginPath();
                    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                    ctx.fill();

                    ctx.save();
                    ctx.translate(this.x, this.y);
                    ctx.rotate(this.turretAngle);
                    ctx.fillStyle = '#ccc';
                    ctx.fillRect(0, -5, this.turretLength, 10);
                    ctx.restore();
                }

                shoot(targetX, targetY) {
                    const angle = getAngle(this.x, this.y, targetX, targetY);
                    const projectile = new Projectile(
                        this.x + Math.cos(angle) * this.turretLength, 
                        this.y + Math.sin(angle) * this.turretLength, 
                        angle,
                        this.game
                    );
                    this.game.addProjectile(projectile);
                    this.game.playShootSound();
                }
                
                resize() {
                    this.x = width / 2;
                    this.y = height - (this.game.isMobile ? 30 : 50);
                    if (this.game.isMobile) {
                        this.radius = 15;
                        this.turretLength = 25;
                    } else {
                        this.radius = 25;
                        this.turretLength = 40;
                    }
                }
            }

            // --- GAME ---
            class Game {
                constructor() {
                    this.isMobile = window.matchMedia("(max-width: 768px)").matches;
                    this.player = new Player(this);
                    this.input = new InputHandler(this);
                    
                    this.state = 'HOME';
                    this.scoreToWin = 35;
                    this.timeLimit = 30000;
                    
                    this.projectiles = [];
                    this.targets = [];
                    this.particles = [];
                    this.score = 0;
                    this.gameTime = 0;
                    this.targetSpawnTimer = 0;
                    this.targetSpawnInterval = 700;

                    this.startButton = null;
                    this.tryAgainButton = null;
                    this.homeButton = null;
                    
                    this.shootSound = new Audio('/shooting/shoot.mp3');
                    this.winSound = new Audio('/shooting/win.mp3');
                    this.loseSound = new Audio('/shooting/lose.mp3');
                }
                
                playShootSound() {
                    this.shootSound.currentTime = 0;
                    this.shootSound.play().catch(e => {});
                }
                playWinSound() {
                    this.winSound.currentTime = 0;
                    this.winSound.play().catch(e => {});
                }
                playLoseSound() {
                    this.loseSound.currentTime = 0;
                    this.loseSound.play().catch(e => {});
                }

                startNewGame() {
                    this.projectiles = [];
                    this.targets = [];
                    this.particles = [];
                    this.score = 0;
                    this.gameTime = 0;
                    this.state = 'PLAYING';
                    this.createInitialTargets();
                }
                
                goToHome() {
                    this.state = 'HOME';
                    finishChallenge("failed",0);
                }

                addProjectile(projectile) {
                    this.projectiles.push(projectile);
                }

                createInitialTargets() {
                    const initialCount = this.isMobile ? 5 : 8;
                    for (let i = 0; i < initialCount; i++) {
                        this.targets.push(new Target(this));
                    }
                }

                update(deltaTime) {
                    if (this.state !== 'PLAYING') return;
                    
                    this.player.update(this.input.mouseX, this.input.mouseY);

                    this.projectiles.forEach(p => p.update());
                    this.projectiles = this.projectiles.filter(p => p.x > 0 && p.x < width && p.y > 0 && p.y < height);

                    this.particles.forEach(p => p.update());
                    this.particles = this.particles.filter(p => p.life > 0);

                    this.targetSpawnTimer += deltaTime;
                    if (this.targetSpawnTimer >= this.targetSpawnInterval) {
                        this.targets.push(new Target(this));
                        this.targetSpawnTimer = 0;
                    }
                    this.targets.forEach(t => t.update());

                    let stateHasChanged = false;
                    this.projectiles.forEach((projectile, pIndex) => {
                        if (stateHasChanged) return;
                        this.targets.forEach((target, tIndex) => {
                            if (stateHasChanged) return;
                            if (getDistance(projectile.x, projectile.y, target.x, target.y) < projectile.radius + target.radius) {
                                for (let i = 0; i < target.radius * 0.5; i++) {
                                    this.particles.push(new Particle(target.x, target.y, target.color));
                                }
                                this.projectiles.splice(pIndex, 1);
                                this.targets.splice(tIndex, 1);
                                this.score++;
                                if (this.score >= this.scoreToWin) {
                                    this.state = 'WIN';
                                    this.playWinSound();
                                    stateHasChanged = true;
                                }
                            }
                        });
                    });

                    if (stateHasChanged) return;

                    this.gameTime += deltaTime;
                    if (this.gameTime >= this.timeLimit) {
                        this.state = 'LOSE';
                        this.playLoseSound();
                    }
                }

                draw(ctx) {
                    ctx.clearRect(0, 0, width, height);

                    if (this.state === 'PLAYING' || this.state === 'WIN' || this.state === 'LOSE') {
                        this.particles.forEach(p => p.draw(ctx));
                        this.targets.forEach(t => t.draw(ctx));
                        this.projectiles.forEach(p => p.draw(ctx));
                        this.player.draw(ctx);
                        this.drawGameUI(ctx);
                    }
                    
                    switch(this.state) {
                        case 'HOME':
                            this.drawHomeScreen(ctx);
                            break;
                        case 'WIN':
                            this.drawWinScreen(ctx);
                            break;
                        case 'LOSE':
                            this.drawLoseScreen(ctx);
                            break;
                    }
                }
                
                drawButton(ctx, text, x, y, w, h, color = '#555', font = '20px sans-serif') {
                    ctx.fillStyle = color;
                    ctx.fillRect(x, y, w, h);
                    ctx.fillStyle = '#fff';
                    ctx.font = font;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(text, x + w / 2, y + h / 2);
                }

                drawHomeScreen(ctx) {
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.min(20, width / 18)}px sans-serif`;
                    ctx.fillText(`Score ${this.scoreToWin} in ${this.timeLimit / 1000} seconds!`, width / 2, height * 0.4);

                    const btnW = Math.min(200, width * 0.6);
                    const btnH = Math.min(50, height * 0.15);
                    const btnX = width / 2 - btnW / 2;
                    const btnY = height / 2;
                    this.startButton = { x: btnX, y: btnY, width: btnW, height: btnH };
                    this.drawButton(ctx, 'Start Game', btnX, btnY, btnW, btnH, '#2a2', `${Math.min(20, width / 22)}px sans-serif`);
                }
                
                drawEndScreenOverlay(ctx) {
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                    ctx.fillRect(0, 0, width, height);
                }

                drawWinScreen(ctx) {
                    this.drawEndScreenOverlay(ctx);
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#0f0';
                    ctx.font = `${Math.min(40, width / 10)}px sans-serif`;
                    ctx.fillText('CONGRATS!', width / 2, height / 2 - 80);
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.min(30, width / 15)}px sans-serif`;
                    ctx.fillText(`Final Score: ${this.score}`, width / 2, height / 2 - 30);
                    setTimeout(()=>{finishChallenge("completed",100)},1000);
                    const btnW = Math.min(200, width * 0.6);
                    const btnH = Math.min(50, height * 0.15);
                    const btnX = width / 2 - btnW / 2;
                    const btnY = height / 2 + 30;
                    this.homeButton = { x: btnX, y: btnY, width: btnW, height: btnH };
                    this.drawButton(ctx, 'Back to Home', btnX, btnY, btnW, btnH, '#555', `${Math.min(20, width / 22)}px sans-serif`);
                }

                drawLoseScreen(ctx) {
                    this.drawEndScreenOverlay(ctx);
                    ctx.textAlign = 'center';
                    ctx.fillStyle = '#f00';
                    ctx.font = `${Math.min(40, width / 10)}px sans-serif`;
                    ctx.fillText('YOU FAILED', width / 2, height / 2 - 80);
                    ctx.fillStyle = '#fff';
                    ctx.font = `${Math.min(30, width / 15)}px sans-serif`;
                    ctx.fillText(`Final Score: ${this.score}`, width / 2, height / 2 - 30);
                    
                    const btnW = Math.min(200, width * 0.6);
                    const btnH = Math.min(50, height * 0.15);
                    const btnFontSize = `${Math.min(20, width / 22)}px sans-serif`;
                    
                    const tryAgainX = width / 2 - btnW / 2;
                    const tryAgainY = height / 2 + 20;
                    this.tryAgainButton = { x: tryAgainX, y: tryAgainY, width: btnW, height: btnH };
                    this.drawButton(ctx, 'Try Again', tryAgainX, tryAgainY, btnW, btnH, '#2a2', btnFontSize);
                    
                    const homeX = width / 2 - btnW / 2;
                    const homeY = tryAgainY + btnH + 15;
                    this.homeButton = { x: homeX, y: homeY, width: btnW, height: btnH };
                    this.drawButton(ctx, 'Back to Home', homeX, homeY, btnW, btnH, '#555', btnFontSize);
                }

                drawGameUI(ctx) {
                    ctx.fillStyle = '#fff';
                    const fontSize = Math.min(24, width / 25);
                    ctx.font = `${fontSize}px sans-serif`;
                    ctx.textAlign = 'left';
                    ctx.textBaseline = 'top';
                    ctx.fillText(`Score: ${this.score} / ${this.scoreToWin}`, 10, 10);

                    const timeLeft = Math.max(0, (this.timeLimit - this.gameTime) / 1000).toFixed(1);
                    ctx.textAlign = 'right';
                    ctx.fillText(`Time: ${timeLeft}`, width - 10, 10);
                }
                
                resize() {
                    this.isMobile = window.matchMedia("(max-width: 768px)").matches;
                    this.player.resize();
                    this.targets = this.targets.filter(t => t.x < width && t.y < height * 0.6);
                }
            }

            // --- INITIALIZATION ---
            resizeCanvas();
            const game = new Game();
            let lastTime = 0;

            function animate(timestamp) {
                const deltaTime = timestamp - lastTime;
                lastTime = timestamp;
                game.update(deltaTime || 0);
                game.draw(ctx);
                requestAnimationFrame(animate);
            }

            window.addEventListener('resize', () => {
                resizeCanvas();
                game.resize();
            });

            animate(0);
        });
        function finishChallenge(text,value) {
            // This is the most important part!
            // We are sending a message to the PARENT window (our Phaser game).
            // The message is a simple object. We can send any data we want.
            const result = {
                challengeStatus: text,
                score: value // You can send back points, items, etc.
            };

            // window.parent refers to the main page that holds the iframe.
            // '*' is a wildcard for the origin. For security, you could replace it
            // with your actual domain when you deploy the game.
            window.parent.postMessage(result, '*');
        }
    </script>
</body>
<style>
         .msg-bar {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  width: auto;
  max-width: 90%;
  padding: 10px 20px;
  margin: 0 auto;
  border-radius: 7px;
  font-size: 1.02rem;
  text-align: center;
  font-family: inherit;
  font-weight: 500;
  opacity: 1;
  transition: background 0.3s, color 0.3s;
  z-index: 9999;
  animation: slideup 0.3s ease-out;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
}

    .msg-bar.error {
      background: #ffebee;
      color: #b71c1c;
      border: 1.5px solid #e57373;
    }
    .msg-bar.success {
      background: #e8f5e9;
      color: #1b5e20;
      border: 1.5px solid #81c784;
    }
    .msg-bar.info {
      background: #e3f2fd;
      color: #01579b;
      border: 1.5px solid #64b5f6;
    }
   @keyframes slideup {
  0% {
    transform: translate(-50%, -20px);
    opacity: 0;
  }
  100% {
    transform: translate(-50%, 0);
    opacity: 1;
  }
}

    </style>
    <script>
function showMsgBar(msg="An error",type="error",d=2000){
    const div=document.createElement("div");
    div.className='msg-bar ' + type;
    div.innerText=msg;
    document.body.appendChild(div);
    setTimeout(()=>{div.remove()},d);

}
document.addEventListener("contextmenu", e =>{ e.preventDefault();showMsgBar("Can't do Right Click", "error");});
document.addEventListener("keydown", e => {
  if (
    e.key === "F12" ||
    (e.ctrlKey && e.shiftKey && ['I', 'J', 'C', 'K'].includes(e.key)) ||
    (e.ctrlKey && e.key === 'U') || (e.ctrlKey && e.key === 'u')
  ) {
    e.preventDefault();
    showMsgBar("Nokkanda, kittoola", "error");
  }
});
console.log("Uff U R BRILLIANT");
console.log("Trying to send your location and Ip Address...");
setTimeout(()=>{console.log("Your location and Ip Address are Sent successfully...");},2500);
    </script>
</html>